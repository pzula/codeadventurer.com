<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Code Adventurer]]></title>
  <link href="http://codeadventurer.com/categories/architecture/atom.xml" rel="self"/>
  <link href="http://codeadventurer.com/"/>
  <updated>2014-11-11T08:51:25-05:00</updated>
  <id>http://codeadventurer.com/</id>
  <author>
    <name><![CDATA[Persa Zula]]></name>
    <email><![CDATA[persa@persazula.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Keeping Things DRY Without Complecting: Table Inheritance]]></title>
    <link href="http://codeadventurer.com/2014/11/11/keeping-things-dry-without-complecting-table-inheritance"/>
    <updated>2014-11-11T08:49:00-05:00</updated>
    <id>http://codeadventurer.com/2014/11/11/keeping-things-dry-without-complecting-table-inheritance</id>
    <content type="html"><![CDATA[<h3>Keeping Things DRY Without Complecting: Table Inheritance</h3>

<p>When dealing with architecture, we find ourselves often dealing with concepts that are similar, yet just slightly different. In an effort to keep our code DRY, we might reach for an abstraction of these concepts all the way down to the data layer, in order to squeeze out more re-use within our codebase. But sometimes, our abstractions can lead to more complexity down the road. I&rsquo;d like to exploire this concept to see how an abstraction can morph over time, and what sort of decisions along the way can help an abstraction become easier or harder to use.</p>

<p>In the following example, we&rsquo;re going to assume that we are building a type of storage and logic system for content types in a small, hosted content-management system.</p>

<p>A content management system can have many kinds of content &mdash; including polls, blog posts, articles, events and so on. When a user opens an account, they are given a few of these default content types to use and customize.</p>

<p>As the engineer, we know that the types of content that our product offers to users will grow as our product grows, so we take a close look at what the content types have in common in order to try to tease out the similarities and build an abstraction that will allow us to easily add more content types in the future.</p>

<p>We find that each kind of content has a lot of the same ideas: we have sections, and each section can have instructions on what to use that section for, and each section can have many different input types.</p>

<p>There could be a problem, though: when a user modifies one of the content types by adding or removing parts, we can end up with data loss if they&rsquo;ve used that content type prior to the modification. By removing the field for author in the future, all prior posts that had an author entry will no longer have that data.</p>

<p>After some thought, we find a way around the problem of data loss. We will have
Templates for each type of content. The template is where a user can customize
how they want to be able to use this input form, from naming the template to
adding, editing and deleting fields and text within sections. Sections can also
be added, edited, or deleted. Some users might want to have a mood input field in
their blog posts. Others might want to have a &lsquo;Related Articles&rsquo; section
available when they add new acticles.  We also want to offer the ability to
bring back anything that has been removed from the template in the past, so each
template will have a &lsquo;Deleted&rsquo; section, where inputs and sections can be
retreived for later use.</p>

<p>However, the Template is only used for storing the structure of how the user
wants to interact with that type of content. When a user actually wants to
create a new piece of content, we will duplicate the structure of the Template
and turn it into a Document. This Document is a snapshot of the Template at that
point in time, and also contains the data entered by the user (such as an article or a blog post). If the Template for that content types gets modified
in the future, it will not affect a Document that has been created for that
content type, because they
are different objects and the data resides in different tables.</p>
]]></content>
  </entry>
  
</feed>
